<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.15">
<meta name="description" content="Why I've given up on Python">
<meta name="author" content="Robert Bennett">
<title>When It Comes to Ditching Python, Now is Better than Never</title>
<link rel="stylesheet" href="./../blog.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./pygments-default.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>When It Comes to Ditching Python, Now is Better than Never</h1>
<div class="details">
<span id="author" class="author">Robert Bennett</span><br>
<span id="email" class="email"><a href="https://github.com/rben01" class="no-underline"><span class="icon"><i class="fa fa-github"></i></span>&#160;</a><a href="https://github.com/rben01">rben01</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Contents</div>
<ul class="sectlevel1">
<li><a href="#_pythons_popularity">Python&#8217;s Popularity</a></li>
<li><a href="#_what_python_does_right">What Python Does Right</a>
<ul class="sectlevel2">
<li><a href="#_abstraction">Abstraction</a></li>
<li><a href="#_package_ecosystem">Package ecosystem</a></li>
<li><a href="#_huge_community_and_wide_support">Huge community and wide support</a></li>
<li><a href="#_its_interpreted_and_has_a_repl">It&#8217;s interpreted and has a REPL</a></li>
</ul>
</li>
<li><a href="#_what_python_does_wrong">What Python Does Wrong</a>
<ul class="sectlevel2">
<li><a href="#_whitespace_based_syntax">Whitespace-based syntax</a></li>
<li><a href="#_package_management">Package management</a></li>
<li><a href="#_python_breaks_its_own_rules">Python breaks its own rules.</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph lead">
<p>And never is <em>not</em> better than right now.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pythons_popularity">Python&#8217;s Popularity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While I will do my best to never use Python in another project of mine, there&#8217;s no doubt that it is generally well liked.
In <a href="https://insights.stackoverflow.com/survey/2020#technology">Stack Overflow&#8217;s 2020 Developer Survey</a>, Python was the #4 most popular language/technology among all developers, a remarkable feat for a language that has zero presence on the web (the top three languages/technologies were JavaScript, HTML/CSS, and SQL).
In addition, Python was the #3 most &#8220;loved&#8221; language (developers who are using it wish to continue to do so) and the #1 most &#8220;wanted&#8221; language (developers who are not yet using it wish to start).
For Python to be so popular, it clearly must have gotten a lot right.</p>
</div>
<div class="paragraph">
<p>This article discusses why I aim to never use Python again; despite everything right with Python, there is too much wrong with it to continue using it.
It&#8217;s not that Python has gotten worse (with the exception of <a href="https://www.python.org/dev/peps/pep-0635/">PEP 635&#8201;&#8212;&#8201;Structural Pattern Matching</a>, an unmitigated disaster), but that the universe of other languages has gotten better while Python has stood still.
In light of this, the first key result from that survey&#8201;&#8212;&#8201;&#8220;After a consistent rise over the last five years, Python fell from second last year to third this year on the list of most loved technologies&#8230;&#8203;&#8221;&#8201;&#8212;&#8201;is not surprising.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_python_does_right">What Python Does Right</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even though it declined in popularity last year, Python is still massively popular.
It&#8217;s not hard to find praise for Python online, but I&#8217;ll summarize what I think are its greatest strengths here.</p>
</div>
<div class="sect2">
<h3 id="_abstraction">Abstraction</h3>
<div class="paragraph">
<p>Python operates at a level of abstraction that allows programmers to focus on the problem at hand while ignoring the implementation details of both computers and Python itself.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python is <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collected</a> and handles memory management for you.</p>
</li>
<li>
<p>Everything, including functions and types, is an object and can be referenced and passed around freely.
The <code>obj.attr</code> syntax is how you access <em>anything&#8217;s</em> attribute, regardless of what kind of object <code>obj</code> actually is.
For instance, you don&#8217;t need to use <code>obj::attr</code> in the event that <code>obj</code> is a type, namespace, module, etc.</p>
</li>
<li>
<p>Iteration &#8220;just works&#8221;.
(I think this was a bigger deal in the early 1990&#8217;s when Python was first released; now we take simple iteration for granted.
But I wouldn&#8217;t be surprised if that&#8217;s because Python showed that there was a right way to do it, which everyone subsequently copied.)</p>
</li>
<li>
<p>Importing packages &#8220;just works&#8221; and the imported module acts like any other Python object.
Heck, you can even <code><a href="https://xkcd.com/353/">import antigravity</a></code>.</p>
</li>
<li>
<p>The relation between syntax and methods is clear and extendable to your own types.
If you want to be able to add your objects together as in <code>x + y</code>, just define <code>__add__(self, other)</code>.
Compare this to, say, Java, in which <code>+</code> may only be used on the primitive numeric types, e.g., even though <code>BigInteger</code> feels like a regular number, it must use <code>x.add(y)</code> because it is a &#8220;real&#8221; type.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_package_ecosystem">Package ecosystem</h3>
<div class="paragraph">
<p>There is a Python package for everything.
As long as performance is not an issue, you will never need to leave the Python ecosystem.
The standard library is huge (a.k.a. &#8220;<a href="https://www.python.org/dev/peps/pep-0206/#batteries-included-philosophy">batteries</a> <a href="https://www.python.org/about/success/wordstream">included</a>&#8221;), so for simple scripts you likely don&#8217;t even need to install external packages.</p>
</div>
</div>
<div class="sect2">
<h3 id="_huge_community_and_wide_support">Huge community and wide support</h3>
<div class="paragraph">
<p>Python has been around forever and has been used a ton.
On Stack Overflow, there are currently 1,756,625 questions with the <code><a href="https://stackoverflow.com/questions/tagged/python?tab=Newest">python</a></code> tag.
For comparison, there are 361,664 questions tagged with <code><a href="https://stackoverflow.com/questions/tagged/c?tab=Newest">C</a></code>, 731,016 tagged with <code><a href="https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Newest">C++</a></code>, 1,787,947 tagged with <code><a href="https://stackoverflow.com/questions/tagged/java?tab=Newest">Java</a></code>, and 2,242,203 tagged with <code><a href="https://stackoverflow.com/questions/tagged/javascript?tab=Newest">JavaScript</a></code>.
If you have a Python question, chances are that it&#8217;s been asked and answered already.
In addition, it is nearly guaranteed that your editor/IDE has superb Python support.</p>
</div>
</div>
<div class="sect2">
<h3 id="_its_interpreted_and_has_a_repl">It&#8217;s interpreted and has a REPL</h3>
<div class="paragraph">
<p>It&#8217;s very handy to be able to <span class="no-wrap">(re-)</span>evaluate code on the fly.
Combined with introspection, this lets you explore unfamiliar territory quickly.</p>
</div>
<div class="sidebarblock">
<div class="content">
Before I get into the next section, it&#8217;s important to recognize that from a technological standpoint, Python is amazing.
A language that&#8217;s easy to write, easy to reason about, and can call down to C when performance is important?
Without a doubt, it is one of the modern marvels of (software) engineering.
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_python_does_wrong">What Python Does Wrong</h2>
<div class="sectionbody">
<div class="paragraph">
<p>But, for all the good ideas present in Python, many of which have percolated into the wider world of programming languages, it is saddled with too many bad ideas for me to continue using it.
Of course, practicality dictates that Python is not going anywhere anytime soon; it has been used in countless projects, and the principle of &#8220;if it ain&#8217;t broke, don&#8217;t fix it&#8221; holds.
But if you can avoid using Python for future work, you should.</p>
</div>
<div class="paragraph">
<p>Here is why.</p>
</div>
<div class="sect2">
<h3 id="_whitespace_based_syntax">Whitespace-based syntax</h3>
<div class="paragraph">
<p>In the before-times, formatting code was something of an art.
One is <em>supposed</em> to indent code correctly to make its structure clear to the reader, and in some instances align it to be aesthetically pleasing, but historically this has been laborious.
So, sometimes people didn&#8217;t do it, or, because they were human, didn&#8217;t do it correctly.
Guido van Rossum, the creator and benevolent dictator for life (BDFL) of Python, had the bright idea to <em>force</em> programmers to correctly indent their code by making indentation the sole indicator of scope.
While most languages used braces to delineate scope, with indentation merely a visual aide for humans, Python decided to nix the braces and imbue indentation with semantics.</p>
</div>
<div class="paragraph lead">
<p><strong>This was a terrible decision that has made editing Python code much more difficult than other languages.</strong></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>My concern here is not with the lack of braces per se, but rather with the use of whitespace instead of beginning and ending delimiters (of any kind).
For instance, Ruby writes if-else statements as <code>if &#8230;&#8203; else &#8230;&#8203; end</code>.
This is fine; like brace-delimited languages, Ruby does not depend on indentation to interpret this because it has the <code>end</code> keyword.
For simplicity, I&#8217;ll refer to any kind of non-whitespace delimiters as &#8220;braces&#8221;.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pasting_code">Pasting Code</h4>
<div class="paragraph">
<p>When cutting and pasting your own code or copying and pasting code from the internet, it&#8217;s difficult to make sure the indentation of the pasted code matches that of the surrounding code. Some examples of problematic scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The indent level of the copied code and the region you wish to paste it into aren&#8217;t the same.</p>
</li>
<li>
<p>They are the same, but you forgot to copy the leading whitespace of the code and pasted into column 0, so the first line is under-indented.</p>
</li>
<li>
<p>They are the same, and you copied the leading whitespace of the code, but pasted into the rightmost column of the current line instead of into column 0, so now the first line is over-indented.</p>
</li>
<li>
<p>The code you&#8217;re pasting uses tabs when your own code uses spaces, or vice versa.
(To determine the indentation level, Python simply counts the number of leading whitespace characters on a line, with some limitations on what combinations of whitespace are allowed.)</p>
</li>
<li>
<p>The code you copied off the internet was itself mis-indented&#8201;&#8212;&#8201;a common formatting error due to Markdown&#8217;s four-space-indent syntax for code blocks&#8201;&#8212;&#8201;so now you must correct its indentation yourself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, immediately after pasting, it&#8217;s possible that the indentation of the pasted code does not correctly reflect the intended semantics.
In a brace-delimited language, this would be fine because indentation does not affect the semantics of the code.
But in Python, copy-pastes have the potential to become exercises in memory and precision&#8201;&#8212;&#8201;after pasting, one must make sure to indent or dedent the pasted code, and <em>only</em> the pasted code, to the correct level.
If this is not performed correctly, then hopefully the code will cease to compile, but it&#8217;s equally likely that a bug will have been introduced.
Python has taken a simple, ubiquitous textual operation&#8201;&#8212;&#8201;one which brace-delimited languages make nearly impossible to mess up&#8201;&#8212;&#8201;and made it arduous and error-prone.</p>
</div>
</div>
<div class="sect3">
<h4 id="_auto_formatters">Auto-formatters</h4>
<div class="paragraph">
<p>Now, one might say, &#8220;It&#8217;s all well and good that brace-delimited languages can withstand poor indentation, but what value does this have if poorly formatted code is forbidden (by company policy, say) from existing in one&#8217;s codebase? Won&#8217;t I still have to correct the formatting manually?&#8221;.
But we no longer live in the before-times, when code formatting was an art; it has been elevated to a science by auto-formatters, technology that can format our code for us!
You can give Prettier, a popular JavaScript autoformatter, a try <a href="https://prettier.io/playground/">here</a>.
The unformatted code on the left side is a mess.
But the (automatically!) formatted code on the right side looks great.
(And crucially, as far as a computer is concerned, the two sides are identical.)
It would take a lot of work to consistently write such well-formatted code.
If you&#8217;re not happy with how the formatted code looks using the default settings, you can change them in the left panel.</p>
</div>
<div class="paragraph">
<p>What&#8217;s notable is that the code on the left was able to be automatically formatted even though the poor formatting meant its semantics were not clear to a human; all that was required by the auto-formatter was that the code be understandable to a computer.
And in turn, this means that the human author has free reign to absolutely butcher the layout of their code while writing it because once they&#8217;re done, the autoformatter will swoop in and clean it up for them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_editing_in_practice">Editing in practice</h4>
<div class="paragraph">
<p>Here are some examples of where Python&#8217;s use of whitespace-based syntax makes it much harder to edit than brace-delimited languages.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">You place your cursor at the end of the line, delete to the start of the line, and then begin typing.</dt>
<dd>
<p>In a brace-delimited language, you can just start typing in column 0, press &#8220;format&#8221;, and the line will be automatically re-indented to the correct column.<br>
This is not possible in Python because text in column 0 carries semantics with it, so moving it would change the program&#8217;s semantics.
Python makes it the programmer&#8217;s responsibility to indent the new text to the same level as the old text.</p>
</dd>
<dt class="hdlist1">You comment out an <code>if</code> statement in order to execute the code below it unconditionally.</dt>
<dd>
<p>In a brace-delimited language, you just comment out the line containing the <code>if</code> (or the lines between the <code>if</code> and the opening brace if the condition spans multiple lines) and the line containing the closing brace.
If you do this and press &#8220;format&#8221;, all the code inside the former <code>if</code> statement will be automatically dedented to account for the change.
Of course, because indentation doesn&#8217;t matter, there is no harm in not pressing &#8220;format&#8221;.<br>
In Python, if you comment out the <code>if</code> line, then you must additionally dedent all of the code that was inside the <code>if</code> statement.
If you decide to uncomment the <code>if</code> line, then you need to reindent all those same lines again.
If you miss a line, it&#8217;s a bug.</p>
</dd>
<dt class="hdlist1">You are using Vim and you want to delete an entire block.</dt>
<dd>
<p>In a brace-delimited languages, this is as easy as typing <code>di{</code> (mnemonic: <code>d</code>elete <code>i</code>nside <code>{</code>}).<br>
This isn&#8217;t possible in Python because there are no block delimiters.</p>
</dd>
<dt class="hdlist1">You wish to comment out an entire block.</dt>
<dd>
<p>In a brace-delimited language, you just comment out each line of the block and nothing will break.<br>
In Python, blocks can&#8217;t be empty, so you have to add <code>pass</code> in place of the block.</p>
</dd>
<dt class="hdlist1">Code wrapping</dt>
<dd>
<p><a href="https://www.python.org/dev/peps/pep-0008/#maximum-line-length">According to PEP 8</a>, lines should be no longer than 79 characters. This is the justification given:</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The default wrapping in most tools disrupts the visual structure of the code, making it more difficult to understand.
The limits are chosen to avoid wrapping in editors with the window width set to 80, even if the tool places a marker glyph in the final column when wrapping lines.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Yes, if you rely on whitespace to interpret code, then soft wraps will make it impossible to figure out what a given piece of code does.
In a brace delimited language, you can easily make sense of a wrapped line because the wrapping doesn&#8217;t affect semantics&#8201;&#8212;&#8201;you can just look for matching braces.
This is especially easy if your editor makes matching braces stand out by highlighting them, coloring them, etc.
It is much harder to make indentation stand out.</p>
</div>
</dd>
<dt class="hdlist1">You have commented out some code, and now wish to uncomment it.</dt>
<dd>
<p>In a brace-delimited language, this is trivial; just uncomment and then autoformat.<br>
Python has auto-formatters too, the most popular of which are <a href="https://github.com/hhatto/autopep8">autopep8</a>, <a href="https://github.com/google/yapf">yapf</a>, and <a href="https://github.com/psf/black">black</a>.
By default, auto-formatters will format comments, indenting them to the level of the surrounding code.
This makes sense when those comments contain ordinary text describing the surrounding code.
But if those comments contain commented out code, then when it comes time to uncomment that code, you must ensure that the uncommented code gets indented back to the right level.
In other words, Python forces you to be mindful of leading spaces, <em>even in your comments</em>.<br>
For instance, suppose we have the following code, but wish to check a different condition.</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-n">cond1</span><span class="tok-p">:</span>
    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">)</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>So we comment out line 1 and add a different condition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-n">cond2</span><span class="tok-p">:</span>  <span class="tok-c1"># let&#39;s test out cond2 for now</span>
<span class="tok-c1"># if cond1:</span>
    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">)</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, black will turn that into this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-n">cond2</span><span class="tok-p">:</span>  <span class="tok-c1"># let&#39;s test cond2 out for now</span>
    <span class="tok-c1"># if cond1:</span>
    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">)</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And if you want to swap <code>cond1</code> back in, you get this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><pre><span></span><span class="tok-c1"># if cond2:  # let&#39;s test cond2 out for now</span>
    <span class="tok-k">if</span> <span class="tok-n">cond1</span><span class="tok-p">:</span>
    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">)</span>
</pre></td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>which is not valid code.
Yes, you can manually dedent line 2, or you could have added the <code>cond2</code> line below <code>cond1</code> instead of above.
But how much effort and attention should these kinds of simple changes really take?</p>
</div>
<div class="paragraph">
<p>In a brace-delimited language such as JavaScript, that flow would look like this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You start with this&#8230;&#8203;</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-nx">cond1</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">console</span><span class="tok-p">.</span><span class="tok-nx">log</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</li>
<li>
<p>You want to test a different condition&#8230;&#8203;</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-nx">cond2</span><span class="tok-p">)</span> <span class="tok-p">{</span>  <span class="tok-c1">// let&#39;s test cond2 out for now</span>
<span class="tok-c1">// if (cond1) {</span>
    <span class="tok-nx">console</span><span class="tok-p">.</span><span class="tok-nx">log</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</li>
<li>
<p>Then you autoformat&#8230;&#8203;</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><pre><span></span><span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-nx">cond2</span><span class="tok-p">)</span> <span class="tok-p">{</span>  <span class="tok-c1">// let&#39;s test cond2 out for now</span>
    <span class="tok-c1">// if (cond1) {</span>
    <span class="tok-nx">console</span><span class="tok-p">.</span><span class="tok-nx">log</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</li>
<li>
<p>Then you swap <code>cond1</code> back in and get this&#8230;&#8203;</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><pre><span></span><span class="tok-c1">// if (cond2) {  // let&#39;s test cond2 out for now</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-nx">cond1</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">console</span><span class="tok-p">.</span><span class="tok-nx">log</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</li>
<li>
<p>Then you autoformat again.</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="javascript"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><pre><span></span><span class="tok-c1">// if (cond2) {  // let&#39;s test cond2 out for now</span>
<span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-nx">cond1</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-nx">console</span><span class="tok-p">.</span><span class="tok-nx">log</span><span class="tok-p">(</span><span class="tok-s2">&quot;a&quot;</span><span class="tok-p">);</span>
<span class="tok-p">}</span>
</pre></td></tr></table></code></pre>
</div>
</div>
</li>
<li>
<p>Success! There&#8217;s no need to fiddle with anything.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In summary, whitespace-based syntax makes the act of actually writing one&#8217;s code much more difficult than it needs to be.
While tying semantics to leading indentation may have been beneficial when Python was first released, auto-formatters have obviated this benefit.
In fact, whitespace-based syntax is a liability because it makes it harder for auto-formatters to do their job.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>There is one kind of whitespace-based syntax that is ok, which is using line breaks to denote the end of a line.
If, in practice, the editing process made it a natural occurrence to inadvertently end up with several statements on one line, then I would argue that languages should require semicolons at the ends of their lines.
But, empirically, the editing process does not generally mangle line breaks, so they can be relied upon for semantics.
(In this regard, newlines are closer to non-whitespace characters than they are to whitespace.)
Leading whitespace <em>is</em> mangled by the editing process and so it should not be relied upon.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_package_management">Package management</h3>
<div class="paragraph">
<p>Pip, Python&#8217;s built-in <a href="https://packaging.python.org/guides/tool-recommendations/">package installer</a>, is notoriously fickle and confusing to use.
Common questions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Should you use <code>pip install</code> or <code>python3 -m pip install</code>?</p>
</li>
<li>
<p>(When) should you use <code>sudo</code> with <code>pip</code>? How about the <code>--user</code> flag?</p>
</li>
<li>
<p>(When) is there a difference between <code>pip</code> and <code>pip3</code>?</p>
</li>
<li>
<p>How important is it to know about <code>setuptools</code>? <code>distutils</code>?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to installing packages, it is also important to be able to manage Python <a href="https://realpython.com/python-virtual-environments-a-primer/">virtual environments</a>.
Python&#8217;s official docs recommend that you use <code><a href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">virtualenv</a></code> for this, and if the Python ecosystem worked correctly, this would be the end of the story.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>To add to the confusion, the name of the package is <code>virtualenv</code> if you&#8217;re on Python 3.2 or older, but <code>venv</code> in Python 3.3 and newer, and it comes bundled with Python 3.3 and newer, but for Python 3.2 or older you need to run <code class="code-allow-wrap">python3 -m pip install --user virtualenv</code>.
At least that answers two of the questions above!</p>
</div>
<div class="paragraph">
<p>To see the chaos that is the Python package management ecosystem, visit <a href="https://packaging.python.org/key_projects/">this page</a>.
Note that this only covers those tools that conform to the <a href="https://packaging.python.org/specifications/">PyPA specifications</a>!</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the void that Python has left, several third-party projects for managing packages and environments have been developed, each with their own pros, cons, and instructions. In general, they are not interoperable, so you have to pick one and hope it serves your needs. Below is a list of the most popular ones with descriptions taken from their home pages.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.conda.io/en/latest/">Conda</a></p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Conda quickly installs, runs and updates packages and their dependencies.
Conda easily creates, saves, loads and switches between environments on your local computer.
It was created for Python programs, but it can package and distribute software for any language.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>One of the first Python package managers that really took off, especially among data scientists, it&#8217;s well-supported by third-party software such as IDEs.
It is completely separate from Python&#8217;s package ecosystem&#8201;&#8212;&#8201;it hosts packages in its own repository separate from <a href="https://pypi.org">PyPI</a>, the repo used by pip.
This means it tends not to have the more niche Python packages.
To add to the confusion, though, conda <em>can</em> use pip to install packages from PyPI packages, but installing from Conda&#8217;s repo is preferred.</p>
</div>
</li>
<li>
<p><a href="https://pipenv.pypa.io/en/latest/">Pipenv</a></p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. Pipenv is primarily meant to provide users and developers of applications with an easy method to setup a working environment.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Rather than reinvent the wheel, Pipenv automates the use of Python&#8217;s builtin package management tools.</p>
</div>
</li>
<li>
<p><a href="https://pypi.org/project/virtualenvwrapper/">virtualenvwrapper</a></p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>virtualenvwrapper is a set of extensions to Ian Bicking’s <a href="http://pypi.python.org/pypi/virtualenv">virtualenv</a> tool.
The extensions include wrappers for creating and deleting virtual environments and otherwise managing your development workflow, making it easier to work on more than one project at a time without introducing conflicts in their dependencies.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For some reason <code>virtualenv</code> needs a wrapper? Go figure.</p>
</div>
</li>
<li>
<p><a href="https://python-poetry.org/">Poetry</a></p>
<div class="quoteblock">
<blockquote>
<div class="hdlist table-row table-row-borders">
<table>
<tr>
<td class="hdlist1">
Develop
</td>
<td class="hdlist2">
<p>Poetry comes with all the tools you might need to manage your projects in a deterministic way.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Build
</td>
<td class="hdlist2">
<p>Easily <strong>build</strong> and <strong>package</strong> your projects with a single command.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Publish
</td>
<td class="hdlist2">
<p>Make your work known by <strong>publishing</strong> it to PyPI.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Track
</td>
<td class="hdlist2">
<p>Having an insight of your project&#8217;s dependencies is just one command away.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Dependency resolver
</td>
<td class="hdlist2">
<p>Poetry comes with an <strong>exhaustive</strong> dependency resolver, which will always find a <strong>solution</strong> if it exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Isolation
</td>
<td class="hdlist2">
<p>Poetry either uses your configured virtualenvs or creates its own to always be <strong>isolated</strong> from your system.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Intuitive CLI
</td>
<td class="hdlist2">
<p>Poetry&#8217;s commands are <strong>intuitive</strong> and easy to use, with sensible defaults while still being configurable.</p>
</td>
</tr>
</table>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Before I swore off Python, this was the package manager I used (after getting tired of Conda&#8217;s dependency solver taking ages to finish).
It worked great, although it took some finagling to get it to work with VS Code.
That&#8217;s one of the issues with having a million tools that do the same thing&#8201;&#8212;&#8201;whether the tool you want to use will be well-supported by others is a matter of luck.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Evidently, Python has not done a good enough job at package management to stave off competing projects.
While Python cannot be blamed for not getting package and environment management correct at the outset, it very much <em>can</em> be blamed for letting it get to this point and continuing to drop the ball on this front.
Compare this to <a href="https://www.rust-lang.org">Rust</a>, which has a single package and environment manager, <a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a>, which is so good that nobody has bothered trying to make a better one. Java has two or three predominant package managers, Ruby has a single one,</p>
</div>
<div class="paragraph">
<p>I&#8217;ll wrap up this section with a quote from Python&#8217;s <a href="https://packaging.python.org/overview/#packaging-applications">own docs</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
Packaging in Python has a bit of a reputation for being a bumpy ride.
This impression is mostly a byproduct of Python’s versatility.
Once you understand the natural boundaries between each packaging solution, you begin to realize that the varied landscape is a small price Python programmers pay for using one of the most balanced, flexible languages available.
</blockquote>
</div>
<div class="paragraph">
<p>I don&#8217;t know, I&#8217;m not buying it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_python_breaks_its_own_rules">Python breaks its own rules.</h3>
<div class="paragraph">
<p>Python has two style guides: <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8&#8201;&#8212;&#8201;Style Guide for Python Code</a>, which deals with stylistic choices when literally writing code, and <a href="https://www.python.org/dev/peps/pep-0020/">PEP 20&#8201;&#8212;&#8201;The Zen of Python</a>, which deals with how best to design an entire program, predominantly from a logic standpoint.
Together, these form <em>the</em> definitive guide to how best use Python to accomplish one&#8217;s goals while maintaining consistency with the greater Python ecosystem.</p>
</div>
<div class="paragraph">
<p>Here is the text of PEP 20, which you can print in a Python REPL with <code>import this</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!</pre>
</div>
</div>
<div class="paragraph">
<p>In theory, these principles are great.
In practice, Python breaks most of them and encourages you to do the same.
&#8220;Pythonic&#8221; code is not necessarily code that is easy to read.
Contrary to the notion that Python is beginner-friendly, understanding Pythonic code often requires familiarity with both Python and the codebase you&#8217;re reading.
What follows are several examples of these issues.</p>
</div>
<div class="sect3">
<h4 id="_names">Names</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Function names</dt>
<dd>
<p><a href="https://www.python.org/dev/peps/pep-0008/#function-and-variable-names">According to PEP 8</a>, &#8220;Function [and variable and method] names should be lowercase, with words separated by underscores as necessary to improve readability. Variable names follow the same convention as function names.&#8221;
Yet <em>several</em> of Python&#8217;s built-in function names do not separate words with underscores: <code>isinstance</code>, <code>classmethod</code>/<code>staticmethod</code>, <code>setattr</code>, and <code>str.startswith</code> come to mind.
Even as recently as version 3.9, Python introduced new methods that broke this rule, <code>str.removeprefix</code> and <code>str.removesuffix</code>.</p>
</dd>
<dt class="hdlist1">Class/type names</dt>
<dd>
<p><a href="https://www.python.org/dev/peps/pep-0008/#class-names">According to PEP 8</a>, &#8220;class names should normally use the CapWords convention.&#8221;
Of course, Python&#8217;s own built-in classes such as <code>int</code>, <code>float</code>, <code>str</code>, <code>list</code>, and <code>dict</code> are exempt from this.
The PEP says that &#8220;there is a separate convention for builtin names&#8221;; it makes no attempt to justify this decision.
Some classes that ship with the Python standard library, but which are not builtins, are written in all lowercase while others are written as CapWords, such as <code>collections.namedtuple</code> and <code>collections.deque</code> and <code>collections.Counter</code> and <code>colletions.ChainMap</code>.</p>
</dd>
<dt class="hdlist1">Constant names</dt>
<dd>
<p><a href="https://www.python.org/dev/peps/pep-0008/#constants">According to PEP 8</a>, &#8220;Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include <code>MAX_OVERFLOW</code> and <code>TOTAL</code>.&#8221;
Not only do <code>True</code>, <code>False</code>, and <code>None</code> break this rule, but they&#8217;re written in CapWords, the style of class names instead of the more sensible all lowercase, the style of variable names.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_explicit_is_better_than_implicit">&#8220;Explicit is better than implicit&#8221;</h4>
<div class="paragraph">
<p>Yet Python <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations">encourages</a> you to &#8220;use the fact that empty sequences are false&#8221;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-c1"># Correct:</span>
<span class="tok-k">if</span> <span class="tok-ow">not</span> <span class="tok-n">seq</span><span class="tok-p">:</span>
<span class="tok-k">if</span> <span class="tok-n">seq</span><span class="tok-p">:</span>

<span class="tok-c1"># Wrong:</span>
<span class="tok-k">if</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-n">seq</span><span class="tok-p">):</span>
<span class="tok-k">if</span> <span class="tok-ow">not</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-n">seq</span><span class="tok-p">):</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t seem very explicit to me.
If I expect <code>seq</code> to be a sequence, then I should signal to other readers that that is my intention, as <code>if seq</code> would also treat <code>0</code> and <code>None</code> as false whereas <code>len(0)</code> and <code>len(None)</code> would both be both runtime errors.
Furthermore, treating non-Boolean values as Booleans is the height of implicitness; being explicit would mean typing <code>if len(seq) == 0</code>, <code>if x == 0</code>, <code>if x is None</code>, etc.
These all specify exactly the condition I am looking for in the most explicit way possible, yet their use is discouraged by Python&#8217;s own docs.</p>
</div>
<div class="paragraph">
<p>You are also encouraged to check if a variable is <code>None</code> with <code>if x is None</code> instead of <code>if x == None</code>.
Implicit in this is the knowledge that <code>NoneType</code> is a singleton type&#8201;&#8212;&#8201;that all instances of <code>NoneType</code> refer to the same object, called <code>None</code>, of which there is only one.
Checking for equality with <code>is</code> instead of <code>==</code> is almost always the wrong thing to do, yet here Python tells us it&#8217;s right, relying on implicit knowledge to justify that decision.</p>
</div>
<div class="paragraph">
<p>Another example of this is that <code>raise MyException</code> is legal, even though <code>MyException</code> is of type <code>type</code>, not <code>Exception</code>.
Why is this?
It&#8217;s because passing a type to <code>raise</code> will instantiate an instance of that type <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement">by calling the type&#8217;s constructor with no arguments</a>.
Not very explicit, and all to save a pair of parentheses.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>If the real motivation behind this decision is to be able to defer the instantiation of the exception until it is definitely needed in case the exception is expensive to construct, then one could ask why not allow any callable to be <code>raise</code>d&#8201;&#8212;&#8201;why must it be a (callable) subtype of <code>Exception</code>?
<code>lambda: MyException()</code> seems much more explicit to me.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_footguns">Footguns</h4>
<div class="paragraph">
<p>PEP 20 (implicitly!) prohibits <a href="https://en.wiktionary.org/wiki/footgun">footguns</a>.</p>
</div>
<div class="paragraph">
<p>Consider the following code. What do you think it will print?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-n">L</span> <span class="tok-o">=</span> <span class="tok-p">[(</span><span class="tok-k">lambda</span><span class="tok-p">:</span> <span class="tok-n">i</span><span class="tok-p">)</span> <span class="tok-k">for</span> <span class="tok-n">i</span> <span class="tok-ow">in</span> <span class="tok-nb">range</span><span class="tok-p">(</span><span class="tok-mi">5</span><span class="tok-p">)]</span>
<span class="tok-nb">print</span><span class="tok-p">([</span><span class="tok-n">f</span><span class="tok-p">()</span> <span class="tok-k">for</span> <span class="tok-n">f</span> <span class="tok-ow">in</span> <span class="tok-n">L</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<details>
<summary class="title">Click to reveal answer</summary>
<div class="content">
It will print <code>[4, 4, 4, 4, 4]</code>.
</div>
</details>
<div class="paragraph">
<p>The <code>i</code>s in the comprehension are captured by the <code>lambda</code>s, survive beyond the lifetime of the comprehension, and are only resolved when actually calling <code>f()</code>.
At that time, they all resolve to 4&#8201;&#8212;&#8201;even though the comprehension doesn&#8217;t exist anymore!
How many rules does <em>this</em> break?</p>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
= How to Make Any SVG Path a CSS Clip Path
:stem: latexmath
:page-stem: {stem}
:page-docdate: 2023-02-17
:page-description: It's easy to fearlessly use any SVG path as a CSS clip-path
:page-keywords: svg, css, style, tricks
:img-url: https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/767px-The_Earth_seen_from_Apollo_17.jpg

++++
<svg id="-shapes-svg" width="0" height="0">
<clipPath id="icon-home-filled-noscale">
<path	d="M 50.019531 11.074219 C 49.423735 11.074219 48.827938 11.286976 48.353516 11.710938 L 47.027344 12.896484 L 19.773438 37.251953 L 9.7910156 46.171875 A 2.5 2.5 0 0 0 9.59375 49.701172 A 2.5 2.5 0 0 0 13.123047 49.900391 L 18.9375 44.705078 L 18.919922 86.458984 C 18.918981 87.8404 20.038505 88.9608 21.419922 88.960938 L 42.925781 88.960938 C 44.305672 88.960801 45.424565 87.842781 45.425781 86.462891 L 45.449219 63.794922 L 54.552734 63.794922 L 54.574219 86.462891 C 54.575419 87.842781 55.694328 88.960801 57.074219 88.960938 L 78.619141 88.960938 C 79.999031 88.960801 81.117925 87.842781 81.119141 86.462891 L 81.138672 44.738281 L 86.916016 49.900391 A 2.5 2.5 0 0 0 90.445312 49.701172 A 2.5 2.5 0 0 0 90.248047 46.171875 L 80.314453 37.296875 L 80.306641 37.287109 L 80.304688 37.287109 L 74.972656 32.521484 L 74.972656 16.6875 C 74.972518 15.306846 73.85331 14.187638 72.472656 14.1875 L 63.814453 14.1875 C 62.4338 14.187638 61.314591 15.306846 61.314453 16.6875 L 61.314453 16.8125 L 61.314453 20.316406 L 55.660156 15.263672 L 51.685547 11.710938 C 51.211125 11.286976 50.615327 11.074219 50.019531 11.074219 z " />
</clipPath>
<clipPath id="icon-home-filled-scale-wrong" clipPathUnits="objectBoundingBox">
<path	d="M 50.019531 11.074219 C 49.423735 11.074219 48.827938 11.286976 48.353516 11.710938 L 47.027344 12.896484 L 19.773438 37.251953 L 9.7910156 46.171875 A 2.5 2.5 0 0 0 9.59375 49.701172 A 2.5 2.5 0 0 0 13.123047 49.900391 L 18.9375 44.705078 L 18.919922 86.458984 C 18.918981 87.8404 20.038505 88.9608 21.419922 88.960938 L 42.925781 88.960938 C 44.305672 88.960801 45.424565 87.842781 45.425781 86.462891 L 45.449219 63.794922 L 54.552734 63.794922 L 54.574219 86.462891 C 54.575419 87.842781 55.694328 88.960801 57.074219 88.960938 L 78.619141 88.960938 C 79.999031 88.960801 81.117925 87.842781 81.119141 86.462891 L 81.138672 44.738281 L 86.916016 49.900391 A 2.5 2.5 0 0 0 90.445312 49.701172 A 2.5 2.5 0 0 0 90.248047 46.171875 L 80.314453 37.296875 L 80.306641 37.287109 L 80.304688 37.287109 L 74.972656 32.521484 L 74.972656 16.6875 C 74.972518 15.306846 73.85331 14.187638 72.472656 14.1875 L 63.814453 14.1875 C 62.4338 14.187638 61.314591 15.306846 61.314453 16.6875 L 61.314453 16.8125 L 61.314453 20.316406 L 55.660156 15.263672 L 51.685547 11.710938 C 51.211125 11.286976 50.615327 11.074219 50.019531 11.074219 z " />
</clipPath>
<clipPath id="arrow-1">
<path d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="arrow-2" clipPathUnits="objectBoundingBox">
<path transform="scale(0.001953125)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="arrow-3" clipPathUnits="objectBoundingBox">
<path transform="translate(.5 .5) scale(0.001953125) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="arrow-4" clipPathUnits="objectBoundingBox">
<path transform="scale(0.0026041667 0.001953125)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="arrow-5" clipPathUnits="objectBoundingBox">
<path transform="translate(.5 .5) scale(0.0009765625) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="four-arrows" clipPathUnits="objectBoundingBox">
<path transform="translate(.25 .25) scale(0.0009765625) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
<path transform="translate(.75 .25) rotate(90) scale(0.0009765625) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
<path transform="translate(.75 .75) rotate(180) scale(0.0009765625) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
<path transform="translate(.25 .75) rotate(270) scale(0.0009765625) translate(-192 -256)" d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z" />
</clipPath>
<clipPath id="four-circles" clipPathUnits="objectBoundingBox">
	<circle cx="0" cy="-65" r="5"></circle> <!-- Top circle -->
	<circle cx="0" cy="-35" r="5"></circle> <!-- Bottom -->
	<circle cx="-15" cy="-50" r="5"></circle> <!-- Left -->
	<circle cx="15" cy="-50" r="5"></circle> <!-- Right -->
</clipPath>
</svg>
<style>
:root {
	--any-svg-clippath-bg-color-1: transparent;
	--any-svg-clippath-bg-color-2: #ddd;
	--dimmed-earth-brightness: .3;
}
@media (prefers-color-scheme: dark) {
	:root {
		--any-svg-clippath-bg-color-1: transparent;
		--any-svg-clippath-bg-color-2: #223355;
		--dimmed-earth-brightness: .2;
	}
}
#-shapes-svg {
	position: absolute;
}
.-fixed-height {
	height: 200px;
}
.-with-bg {
	background:
    repeating-conic-gradient(var(--any-svg-clippath-bg-color-1) 0% 25%, var(--any-svg-clippath-bg-color-2) 0% 50%)
      50% / 16px 16px;
	line-height: 0;
}
.-with-bg > p {
	position: relative
}
.-dim > img {
	filter: grayscale(100%)  brightness(var(--dimmed-earth-brightness)) ;
	clip-path: circle(44.5% at center);
}
.-pos-abs {
	position: absolute;
	left: 0;
	right: 0;
	margin: 0 auto;
}
.-pos-abs.-half-image {
	/* half of (image's width + column gap) */
	transform: translateX(65px);
}
.-half-image.-dim {
	clip-path: ellipse(89% 44.5% at 100% 50%);
}
.-clipped {
	clip-path: url(#icon-home-filled);
	display: inline-block;
}
.-clipped.-clipped-wrong {
	clip-path: url(#icon-home-filled-noscale)
}
.-clipped.-clipped-scaled-wrong {
	clip-path: url(#icon-home-filled-scale-wrong)
}
.-clipped.-clipped-arrow-1 {
	clip-path: url(#arrow-1);
}
.-clipped.-clipped-arrow-2 {
	clip-path: url(#arrow-2);
}
.-clipped.-clipped-arrow-3 {
	clip-path: url(#arrow-3);
}
.-clipped.-clipped-arrow-4 {
	clip-path: url(#arrow-4);
}
.-clipped.-clipped-arrow-5 {
	clip-path: url(#arrow-5);
}
.-clipped.-clipped-four-arrows {
	clip-path: url(#four-arrows);
}
.-clipped.-clipped-four-circles {
	clip-path: url(#four-circles);
}
#four-circles circle {
	transform: translate(.5px,.5px) scale(.01) translate(0px,50px);
}
.-clipped img {
	object-fit: cover;
}
.-marble {
	display: inline-block;
	width: 200px;
	height: 200px;
}
.-marble.-arrow {
	height: 100px;
	aspect-ratio: 384 / 512;
	width: revert;
}
.-marble.-arrow,
#circles-svg {
	border: 2px dashed var(--default-text-color);
}
.-marble.-arrow path {
	fill: var(--default-text-color);
}
.-half-image {
	width: 100px;
	overflow: hidden;
}
body .doc .image.-half-image img {
	width: 200px;
	height: 200px;
	object-fit: cover;
	object-position: 0;
}
.halign-center.-with-bg > p {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	justify-content: center;
	column-gap: 30px;
}
#circles-svg circle {
	fill: var(--default-text-color);
}
</style>
++++

[.lead]
This article describes a general-purpose method to turn just about any SVG into a `<clipPath>` that will correctly clip arbitrary HTML elements.

== Clipping Paths

=== The Basics of Clipping Paths

The https://developer.mozilla.org/en-US/docs/web/css/clip-path[`clip-path`] property is a https://caniuse.com/?search=clip-path[relatively new and not fully supported] (or old and fully supported, depending when you're reading this) CSS property.footnote:[At the time of writing, Firefox was the only browser that https://caniuse.com[Can I Use] listed as fully supporting the feature. Other browsers had the following limitation: "`Partial support refers to supporting shapes and the ``url(#foo)`` syntax for inline SVG, but not shapes in external SVGs.`"]
It allows using a https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape[shape] to specify a _clipping region_ for the given HTML element: a region outside of which the element is not drawn.
In other words, the clipping region is like a mask{empty}footnote:[But not to be confused with an "`actual`" https://developer.mozilla.org/en-US/docs/web/css/mask[CSS mask], which acts like a translucent film covering the background image.
It's possible for parts of the background image to show through only partially, which is not the case for ``clip-path``s.] that only lets through portions of the background within the region's interior (or equivalently, that blocks the portions of the background outside of the region).
For instance, here is https://en.wikipedia.org/wiki/The_Blue_Marble[_The Blue Marble_], followed by the same image with a "`home`" icon as its clipping path (the checkerboard background is to aid viewing by showing exactly where the boundary of each image is):

====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,,link=https://en.wikipedia.org/wiki/File:The_Earth_seen_from_Apollo_17.jpg,window=_blank,role="-marble"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped"]
====

[NOTE]
====
Regardless of what portion of the image lies inside the clipping region, the image itself still takes up the full amount of space it normally would.
Clipping doesn't affect the size of elements or how they're laid out, just what portion of them we actually see.
The portion outside the clipping region just appears transparent.
====


Note how the clipping region is centered over the image and fills the entire space; we'll come back to this later.
For now, let's just confirm this fact by overlaying the clipped image on a dimmed copy of the original with the black corners of the background removed:
====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped"]
====
From now on, we'll always show our clipped images overlaid on a dimmed planet Earth.

Valid ``clip-path``s are in approximately one-to-one correspondence with shapes in SVG: you can clip with circles, polygons, paths, and more:

[source,css]
----
clip-path: inset(100px 50px);
clip-path: circle(50px at 0 100px);
clip-path: ellipse(50px 60px at 0 10% 20%);
clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
clip-path: path(
  "M0.5,1 C0.5,1,0,0.7,0,0.3 A0.25,0.25,1,1,1,0.5,0.3 A0.25,0.25,1,1,1,1,0.3 C1,0.7,0.5,1,0.5,1 Z"
);
----

Thankfully, unlike their SVG counterparts, these ``clip-path`` shapes understand dimensions written in CSS units and even some special keywords.
So it's easy to write, say, "`clip this element with an ellipse that extends precisely to its horizontal and vertical edges`": it's just `clip-path: ellipse(50% 50% at center)`.
In fact, the black background of _The Blue Marble_ was removed with `clip-path: circle(44.5% at center)`.
Couldn't be easier.


That is, unless you're using `clip-path: path(...)`, which takes a good old-fashioned https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths[SVG path string], which does _not_ support these fancy CSS units.
In addition to using a somewhat arcane syntax{empty}footnote:[Here's a valid path string: `a.25.25 0 01-.25-.25`. The `a` stands for "`arc from here`"; a number can only have a single decimal point, so you don't need a space between the _two_ consecutive decimal numbers `.25,.25` in `.25.25`; no integer except `0` itself will start with a `0`, so `0 01` is `0,0,1`; and there's only one sensible way to parse `-.25-.25`, which is `-.25,-.25`, since numbers that have a minus sign must begin with it.
Of the seven arguments to `a`, two are boolean flags, and _must_ be written as integers, not floats.],
SVG paths must be written in terms of unit-less numbers, which specify the location of their path's elements, such as a line, an arc, or a Bezier curve, in absolute units on the Cartesian plane.
Therefore, if you want to use a path to clip an element, you must know the dimensions of the element.
For instance, to draw a path that references the center of the element, you would need to know the width and height of the element and then divide them by 2 yourself.
`50%` just isn't available in `path(...)`.

[NOTE]
--
It can get confusing going back and forth between SVG and CSS, as SVG elements have many attributes that are also valid CSS properties.
For instance, `<circle stroke-width="3"></circle>` is a valid SVG shape (or it would be if we also included `cx`, `cy`, and `r`), but so is `<circle></circle>` with accompanying CSS `circle { stroke-width: 3; }`.
Throughout this article, unless otherwise specified, `clip-path` will always refer to the CSS property, not the SVG attribute.
For a list of other properties that can be used as both, see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/Presentation[here].
--

=== Using SVG ``<clipPath>``s

There is one other way to specify a shape to use as `clip-path`: the `clip-path: url(#clippath-id)` syntax.
This looks up the https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath[`<clipPath>`] element with the given ID — which must live in some SVG on the page — and uses the union of the regions clipped by its shapes{empty}footnote:[These shapes don't have to be ``<path>``s; they can be any SVG shape with a closed boundary, which includes `<path>` (which are automatically closed in this context) but also `<circle>`, `<rect>`, `<polygon>`, etc., but not, for instance, `<line>`.] to construct the clipping region.
The `<clipPath>` itself is not drawn in the SVG; it is merely referenced by other shapes or HTML elements, who use it as their `clip-path`.

But ``<clipPath>``s are still SVG elements, so they are drawn in absolute coordinates.
This means that if we have the following SVG path — a house-shaped `<clipPath>` similar to the one used above — which has (implicit{empty}footnote:[How do I know?
Because the SVG it came from had `viewBox="0 0 100 100"`.
We'll talk more about `viewBox` below.]) dimensions 100×100...
[source,svg]
----
<svg>
<clipPath id="icon-home-100x100">
	<path
		d="M 50.019531 11.074219
		   C 49.423735 11.074219 48.827938 11.286976 48.353516 11.710938
			L 47.027344 12.896484
			L 19.773438 37.251953
			L 9.7910156 46.171875
			A 2.5 2.5 0 0 0 9.59375 49.701172
			A 2.5 2.5 0 0 0 13.123047 49.900391
			L 18.9375 44.705078
			L 18.919922 86.458984
			C 18.918981 87.8404 20.038505 88.9608 21.419922 88.960938
			L 42.925781 88.960938
			C 44.305672 88.960801 45.424565 87.842781 45.425781 86.462891
			L 45.449219 63.794922
			L 54.552734 63.794922
			L 54.574219 86.462891
			C 54.575419 87.842781 55.694328 88.960801 57.074219 88.960938
			L 78.619141 88.960938
			C 79.999031 88.960801 81.117925 87.842781 81.119141 86.462891
			L 81.138672 44.738281
			L 86.916016 49.900391
			A 2.5 2.5 0 0 0 90.445312 49.701172
			A 2.5 2.5 0 0 0 90.248047 46.171875
			L 80.314453 37.296875
			L 80.306641 37.287109
			L 80.304688 37.287109
			L 74.972656 32.521484
			L 74.972656 16.6875
			C 74.972518 15.306846 73.85331 14.187638 72.472656 14.1875
			L 63.814453 14.1875
			C 62.4338 14.187638 61.314591 15.306846 61.314453 16.6875
			L 61.314453 16.8125
			L 61.314453 20.316406
			L 55.660156 15.263672
			L 51.685547 11.710938
			C 51.211125 11.286976 50.615327 11.074219 50.019531 11.074219
			z "
	/>
</clipPath>
</svg>
----

and we try to use it as the `clip-path` of our _The Blue Marble_, which has dimensions 200×200, using the following CSS...
[source,css]
----
.blue-marble {
	clip-path: url(#icon-home-100x100);
}
----
then we end up with this:

====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-wrong"]
====

This time, the clipping region does not take up the entire image; it exists entirely within the 100×100 region in the upper left because the width and height of the ``<clipPath>``’s `<path>` were both 100.
So, how can we fix this to achieve what we saw above, in which the house covered the whole _Blue Marble_?
How can we get the clipping region to span the entire 200×200 image?


=== `clipPathUnits`

Very helpfully, `<clipPath>` has an attribute, `clipPathUnits`, that lets us specify exactly what the units of the `<clipPath>` represent.
The default value, `userSpaceOnUse`, leads to the behavior we just saw: it assumes the `<clipPath>` and the HTML element it is clipping use the same coordinate system.
So, our `<clipPath>`, which only existed in the square from `(0, 0)` to `(100, 100)`, created a clipping region that only exposed the home-shaped part of the image in that same upper-left square.

The other choice for `clipPathUnits` is `objectBoundingBox`, which assumes that the `<clipPath>` occupies a merely 1×1 square, which is then stretched or compressed in both dimensions so that it has the same dimensions as the element it is clipping.

Let's add `clipPathUnits="objectBoundingBox"` to our `<clipPath>` above and use it to clip _The Blue Marble_ again.

====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-scaled-wrong"]
====

But that's just the background.
Where'd our clipped image go?

As mentioned, `objectBoundingBox` _assumes_ that the `<clipPath>` occupies a merely 1×1 square.
But our `<clipPath>` _actually_ still occupies a 100×100 square and, crucially, does not include anything in its upper left 1×1 corner.
In other words, our `<clipPath>` completely missed _The Blue Marble_; the region it would expose is way, way down to the bottom right.footnote:[The image is 200×200, and the `<clipPath>` is 100×100, so the entire region it's attempting to clip is 20,000×20,000.
The diagonal that forms the left part of the house's roof is well beyond the edges of the screen, let alone the image we want to clip.]
We have to figure out how to get our ``<clipPath>``’s `<path>` down into a 1×1 square.

== Transforming ``<clipPath>``s
=== Shrinking the `<path>`
The hard way to do this would be to simply edit our `<path>`: take all the numbers and divide them by 100 (except for the boolean flags!).
But this would be tedious and would make it hard to just use any old SVG icon as a `<clipPath>`.
Thankfully, there is a very easy way to transform SVG elements, which is... https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform[the `transform` attribute].
[#linear-transformation]#`transform`# applies a https://en.wikipedia.org/wiki/Linear_map[linear transformation] to an element, and scaling by a factor of 1/100 is a linear transformation, so we're good.
All we have to do is add ``transform: scale(.01)`` to the `<path>` (not to the `<clipPath>`!), and we get a lovely 1×1 `<clipPath>` which clips as we expect.
This is precisely how the original clipped image in this article, shown again below, was created.
====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped"]
====

For completeness, here is the final SVG.
(In case you're copy-pasting this somewhere, note that we've changed the `id` of the `<clipPath>`.)

[source,svg]
----
<svg>
<clipPath id="icon-home-1x1" clipPathUnits="objectBoundingBox">
	<path transform="scale(.01)" d="same home path" />
</clipPath>
</svg>
----

[TIP]
====
If you want to use multiple ``<clipPath>``s in the same document, they don't all need their own SVG.
Putting them all in the same SVG is fine, like so:

[source,svg]
----
<svg>
<clipPath id="clippath-1">...</clipPath>
<clipPath id="clippath-3">...</clipPath>
<clipPath id="clippath-3">...</clipPath>
...
</svg>
----
====

For _images_ that aren't square, the `<clipPath>` scales separately in each dimension.
Here's just the left half of _The Blue Marble_, and next to it is what happens when we use the house to clip just that half (which is now twice as tall as it is wide).
====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -half-image"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -half-image -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -half-image"]
====

But what happens when it's the _``<clipPath>``_ that isn't square?

=== Non-Square Clip Paths

So far we've been taking advantage of a very nice property of our `<clipPath>`: its width and height are the same, so we could scale them down by the same amount.
This meant that if the original path was centered in its 100×100 bounding box, then the clipping region would also be centered in the element it was clipping.

But what if it weren't square?
Here is the `arrow-up` icon from https://fontawesome.com/[Font Awesome], which is taller (512) than it is wide (384):
[source,svg]
----
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
<!--! Font Awesome Pro 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
<path
	d="M214.6 41.4
	   c-12.5-12.5-32.8-12.5-45.3 0
	   l-160 160
	   c-12.5 12.5-12.5 32.8 0 45.3
	   s32.8 12.5 45.3 0
	   L160 141.2
	   V448
	   c0 17.7 14.3 32 32 32
	   s32-14.3 32-32
	   V141.2
	   L329.4 246.6
	   c12.5 12.5 32.8 12.5 45.3 0
	   s12.5-32.8 0-45.3
	   l-160-160
	   z" />
</svg>
----

Now is a good time to talk about the SVG's `viewBox` attribute.
If you imagine the shapes in the SVG lying in the infinite Cartesian plane, the `vieBox` tells us what rectangle in the plane to restrict our attention to; nothing outside this rectangle is drawn.
(In a sense, the `viewBox` is like the `clip-path` of whole SVG, which would otherwise be infinitely large.)
``viewBox``es take the form of `"x y w h"`, where `x` is the x-position of the rectangle's upper left corner, `y` is that corner's y-position, and `w` and `h` are the rectangle's width and height, respectively.
The `arrow-up` SVG has its origin at `(x, y) = (0, 0)` and has a width of 384 and a height of 512.

NOTE: I've drawn a border around the arrow to show its dimensions; the border isn't part of the icon itself.

====
++++
<div class="halign-center -with-bg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="-marble -arrow"><!--! Font Awesome Pro 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"/></svg>
</div>
++++
====

How do we use this as a `clip-path`?
What we'd like to achieve is an arrow-shaped clipping region the same size as, and centered on, _The Blue Marble_, as shown below.
====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-arrow-3"]
====

So, how do we make this happen?

Let's try our `transform` trick from above; maybe it'll still work here.
[source,svg]
----
<svg>
<clipPath id="arrow-1" clipPathUnits="objectBoundingBox">
	<path
		transform="scale(0.001953125)" <!--1--><!--2-->
		d="same home path"
	/>
</clipPath>
</svg>
----
<1> 0.001953125 = 1/512, which gets our shape with dimensions 384×512 to lie entirely in a 1×1 square.
<2> Unfortunately, SVG doesn't let you write out the scale factor as a literal division like `1 / 512`, so you've got to plug the division into a calculator and write out the resulting decimal number.


====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-arrow-2"]

====

This is close, but not quite right — it isn't centered!
Eyeballing, it looks like it only covers the left three-quarters of the image.
Hmm.

_Why_ isn't it centered?
Well, the original icon had a width of 384 and a height of 512.
When we scaled it by 1/512 = 0.001953125, we made sure the new _height_ went from 0 to 1.
But the new _width_ also got divided by 512, which means that it only goes from 0 to 384/512 = 0.75, which indeed is not all the way over to 1.
That's why the arrow above only seems to cover the left three-quarters of the image — its maximum x-coordinate is only 0.75.

So what can we do about this?
A bad solution would be to scale the width and height separately.
While this would get the ``<clipPath>``’s `<path>` to have dimensions 1×1, it would not preserve the original aspect ratio, and so we'd be using a fundamentally different shape.
Here's what that would look like, with `transform: scale(0.0026041667 0.001953125)` (1/384 = 0.0026041667).

====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-arrow-4 -pos-abs"]

====
Yech.

=== Centering the `<clipPath>`

What we need to do is translate our correctly-scaled-down `<path>` so that it's centered in the 1×1 box.
But how much do we need to translate it by?
After scaling it down, its left edge was at 0 and its right edge was at 0.75, so we need to shift it to the right by (1 - 0.75)/2, or 0.125.
If an arbitrary shape's upper left corner is at `(x, y) = (0, 0)` and the shape has width `w` and height `h`, then its center is at `(w/2, h/2)`.
Assuming https://en.wikipedia.org/wiki/Without_loss_of_generality[without loss of generality] `w < h`, after scaling it down by `1/h` the center would end up at `(w/(2*h), 1/2)`.
The translation that moves this point to `(0.5, 0.5)` would be `(0.5-w/(2*h), 0)`, or `((1-w/h)/2, 0)`, which is indeed what we found above.
So the correct transformation to apply to the `<path>` would be `transform: translate(.125 0) scale(0.001953125)` -- that's "scale by 1/512, then translate `x` and `y` by 0.125 and 0, respectively".footnote:[The individual transformations in a `transform` are applied right to left, not left to right.
This seems backwards until you consider transformations as left-multiplication of some element: `translate(...) * scale(...) * element`.
Since we only know how to apply a transformation to an element, not another transformation, this must be parenthesized as `translate(...) * (scale(...) * element)`, from which it follows that `translate(...) scale(...)` (we've dropped the explicit asterisk now) must represent a `scale(...)` followed by a `translate(...)`.
Naturally, this right-to-left reading follows the mathematical rules of https://en.wikipedia.org/wiki/Transformation_matrix#Composing_and_inverting_transformations[composing linear transformations].]
If our `<clipPath>` was wider than it was tall, say, 200×100, then we'd scale it by 1/200 = .005 and translate it _downward_ by `(1 - 100/200)/2 = 0.25`.

We've solved the problem for SVGs whose ``viewBox``'s origin is at `(x, y) = (0, 0)`.
What about for SVGs whose origin is elsewhere?footnote:[In practice, you almost never see an SVG whose upper left corner isn't at `(0, 0)`.
But the spec allows it, so we have to support it.]
If the `viewBox` is `"x y w h"`, then the center of the shape would be at `(x+w/2, y+h/2)`.
Again assuming that `w < h`, we'd scale by `1/h` to get it to fit in a a 1×1 square, which would move the center to `((x+w/2)/h, (y+h/2)/h)`.
Then, to get the center to be located at `(0.5, 0.5)`, we'd translate it by `(0.5-(x+w/2)/h, 0.5-(y+h/2)/h)`.
The resulting transformation would be
[source,svg]
----
transform="translate(0.5-(x+w/2)/h 0.5-(y+h/2)/h) scale(1/h)"
----

=== A Better Solution

At this point we've technically solved the problem.
But the solution is pretty ugly; it requires an annoying amount of busywork with a calculator and there is no way to see where the decimals in the `transform` came from at a glance.
There is also a strong implicit dependence on `w` being smaller than `h`.
We can do better!

What we would really like to do, if it were possible, is *center the `<path>` first, and _then_ scale it down*.
However, the `scale(...)` transform always scales relative to the origin: the result of scaling a point `(x, y)` by `s` will always be `(s*x, s*y)`.
You don't get to specify your own "`scale origin`", so translating and then scaling won't work.

If what we're looking for is a simpler way to translate our post-scale `<path>` — something simpler than `translate(0.5-(x+w/2)/h, 0.5-(y+h/2)/h)` — maybe we should perform the scaling on the shape when it's centered at the origin.
Then translating it to the correct final position would simply be `translate(.5 .5)` — that's the center of a 1×1 square, after all.
But how can we get the shape to be centered at the origin?

Easy: we simply apply `translate(-(x+w/2) -(y+h/2))` first!
This moves the shape's center to the origin of the coordinate system.
So, to scale our `<path>` correctly, we simply need the following:

[source,svg]
----
transform="translate(.5 .5) scale(1/max(w, h)) translate(-(x+w/2) -(y+h/2))"
----
IMPORTANT: Remember, you actually have to do these divisions out to get a decimal number.
You can't literally write e.g., `1 / 512`.

To make the translations really explicit, we can even split them up:
[source,svg]
----
transform="translate(.5 .5) scale(1/max(w, h)) translate(-w/2 -h/2) translate(-x -y)"
----

In English (remember, the functions are applied right to left):

. Translate the SVG so that its upper left corner is at `(0, 0)`.
. Then, translate it so that its center is at the origin.
. Then, scale it so that it fits in a 1×1 square.
. Then, translate it so that its center is at `(0.5, 0.5)`, the center of a 1×1 square.

Why is this better?
To start, we've got only one calculation we might need a calculator for, and that's `1/max(w, h)`; `w/h` and `h/w` are just gone altogether.
In addition, if, say, `w` changes, it's trivial to update `translate(-w/2 -h/2)` with the new value of `w/2`, and if `w < h` remains the same then that's the only change you have to make at all.
Finally, this `transform` is self-documenting in two ways.
First, you have the original `viewBox` of the `<path>` written out in `translate(-w/2 -h/2) translate(-x -y)`.
And second, while the decimal number in the `scale(...)` is inscrutable except in the simplest cases, when you write the `transform` this way, you know it's just the reciprocal of twice the larger of the two numbers in `translate(-w/2 -h/2)`.

Putting it all together, then:
[source,svg]
----
<svg>
<clipPath id="arrow-2" clipPathUnits="objectBoundingBox">
	<path
		transform="translate(.5 .5) scale(0.001953125) translate(-192 -256)" <!--1-->
		d="same arrow path"
	/>
</clipPath>
</svg>
----
<1> Negative one-half of 384 and 512, respectively.
We know, then, that 0.001953125 must be the reciprocal of the larger of 384 and 512.
The original SVG had its upper left corner at `(0, 0)`, so we don't need to handle that in this case.

Which, as expected, leads to this:
====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-arrow-3 -pos-abs"]
====

Success!

== Going Further
=== Other Transforms

If we only ever wanted to place a `<clipPath>` in the center of our element and have it cover the whole element, we know everything we need to know.
But we can use this same technique to apply more exotic transformations to `<clipPath>` elements as well.

A simple next step would be to have our `<clipPath>` remain centered, but be smaller than its full size.
This is easy to do: we just change the scale from `1/h` to something smaller.
If we want our arrow to be half-size, we'll scale it by half of 1/512, or 1/1024 = 0.0009765625.

[source,svg]
----
<svg>
<clipPath id="arrow-4" clipPathUnits="objectBoundingBox">
<path transform="translate(.5 .5) scale(0.0009765625) translate(-192 -256)" d="same arrow path" />
</clipPath>
</svg>
----

This gets us
====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-arrow-5 -pos-abs"]
====


To go even further, suppose we wanted a `<clipPath>` consisting of four copies of the arrow, each of which clips one of the corners of the original image and is rotated 90° from the previous one.
Rather than scale the ``<path>``s down to 1×1, we'll scale them down to 0.5×0.5.
And instead of translating them to `(0.5, 0.5)`, we'll translate them to `(0.5±0.25, 0.5±0.25)`.
Since, like scaling transformations, rotations are always applies about the origin, we to apply the rotation _before_ the final translation so that the shapes are rotated about their center.

[source,svg]
----
<svg>
<clipPath id="four-arrows" clipPathUnits="objectBoundingBox">
<path transform="translate(.25 .25) scale(0.0009765625) translate(-192 -256)" d="same arrow path" />
<path transform="translate(.75 .25) rotate(90) scale(0.0009765625) translate(-192 -256)" d="same arrow path" />
<path transform="translate(.75 .75) rotate(180) scale(0.0009765625) translate(-192 -256)" d="same arrow path" />
<path transform="translate(.25 .75) rotate(270) scale(0.0009765625) translate(-192 -256)" d="same arrow path" />
</clipPath>
</svg>
----

====
[.halign-center.-with-bg.-fixed-height]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-four-arrows -pos-abs"]
====


=== Multiple Shapes in One `<clipPath>`, and CSS ``transform``s

We now know how to take just about any SVG shape at all, such as `<path>`, `<ellipse>`, and `<polygon>`, and turn it into a `<clipPath>`.
But what about collections of shapes?
If an SVG contains several shapes, what's the right way to form a `<clipPath>` out of them?
We'll need a way to transform them all in lock step.

It's simple to adapt the above technique to this more complex problem.

. In the `<clipPath>`, add all of the shapes from the original SVG.
. Set all of those shapes’ ``transform``s (not the ``<clipPath>``'s `transform`!) to `transform: translate(.5 .5) scale(1/max(w, h)) translate(-(x+w/2) -(y+h/2))`.
You can do this by adding the transform to each shape individually, but it's probably easier to use CSS.footnote:[
If you're familiar with the https://developer.mozilla.org/en-US/docs/Web/SVG/Element/g[`<g>`] element, which is a simple "`container element`" that groups SVG elements together, you might be wondering why we didn't put the circles in a `<g>` inside the `<clipPath>` and then apply the `transform` to the `<g>`.
Surely this would be simpler?
The short answer is that https://stackoverflow.com/q/66417211[you "`just can't`"] — https://www.w3.org/TR/SVG11/masking.html#EstablishingANewClippingPath[the spec] forbids placing `<g>` elements in a `<clipPath>`, period.
]
+
[IMPORTANT]
====
The syntax used to specify the `transform` property in CSS is a bit different from the syntax used when `transform` is an SVG attribute.
Most importantly, *numbers in CSS _require_ units after them*.
When using CSS to style SVG elements, you almost certainly want to use `px`, pixels, as your units.
(Numbers in SVGs don't take explicit units because they are already implicitly in units of pixels.)
There are other differences as well, e.g., `translate(dx, dy)` _needs_ a comma between `dx` and `dy` in CSS, whereas the comma is optional in an SVG.
====

So, suppose we had the following SVG, which contains four circles equally spaced around its center.
[source,svg]
----
<!-- Origin at (x, y) = (-25, -100), dimensions (w, h) = (50, 100) -->
<svg viewBox="-25 -100 50 100">
	<circle cx="0" cy="-65" r="5"></circle> <!-- Top circle -->
	<circle cx="0" cy="-35" r="5"></circle> <!-- Bottom -->
	<circle cx="-15" cy="-50" r="5"></circle> <!-- Left -->
	<circle cx="15" cy="-50" r="5"></circle> <!-- Right -->
</svg>
----

Again, I'll draw a border around the SVG.

====
++++
<div class="halign-center -with-bg">
<p>
<svg id="circles-svg" viewBox="-25 -100 50 100" width="75" height="150">
<circle cx="0" cy="-65" r="5"></circle> <!-- Top circle -->
<circle cx="0" cy="-35" r="5"></circle> <!-- Bottom -->
<circle cx="-15" cy="-50" r="5"></circle> <!-- Left -->
<circle cx="15" cy="-50" r="5"></circle> <!-- Right -->
</svg>
</p>
</div>
++++
====

To turn these four circles into a `<clipPath>`, we'll just follow the instructions above.
The `viewBox` is `"-25 -100 50 100"`, so the initial translation is `translate(-25 -50) translate(25 100)`, or `translate(0 50)`.
The largest dimension is the height, 100.
So, the transformation we need is (in CSS syntax, since that's how I'll apply it):
[source,css]
----
#four-circles > circle {
	transform: translate(.5px,.5px) scale(.01) translate(0px,50px);
}
----
IMPORTANT: Don't forget the `px` and commas!

And the SVG we need is
[source,svg]
----
<svg>
<clipPath id="four-circles" clipPathUnits="objectBoundingBox">
	<circle cx="0" cy="-65" r="5"></circle> <!-- Top circle -->
	<circle cx="0" cy="-35" r="5"></circle> <!-- Bottom -->
	<circle cx="-15" cy="-50" r="5"></circle> <!-- Left -->
	<circle cx="15" cy="-50" r="5"></circle> <!-- Right -->
</clipPath>
</svg>
----

This results in

====
[.halign-center.-with-bg]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -pos-abs -dim"]
image:{img-url}[_The Blue Marble_ clipped by a home icon,role="-marble -clipped -clipped-four-circles"]
====

It works!


[appendix]
== Matrices

[NOTE]
====
This section assumes some basic linear algebra knowledge.
====

Above, we found two ways of transforming our `<clipPath>`, one of the form `translate(...) scale(...)` and the other of the form `translate(...) scale(...) translate(...)`.
How can we verify that these were, in fact, equivalent?

As mentioned <<linear-transformation,above>>, the transformations in `transform` are https://en.wikipedia.org/wiki/Linear_map[linear transformations], which can be represented by matrices.
We should verify that the two forms of our `transform` do in fact encode the same linear transformation.
We can do this by comparing their matrices.

Since we're in a 2D vector space, we might expect that our matrices would be 2×2 and operate on 2D vectors.
Unfortunately, were this the case, we'd have no way of representing translations, which are not linear transformations.footnote:[For one, they don't send `(0, 0)` to itself.]
There is a https://en.wikipedia.org/wiki/Affine_transformation#Augmented_matrix[trick] to fix this: we work in a 3D vector space and write the point `(x, y)` as `(x, y, 1)`.
Then, the translation matrix stem:[T_{t_x,t_y}] and the scale matrix stem:[S_s] can be written as follows;
[stem]
++++
\begin{aligned}
T_{t_x,t_y}&=\begin{bmatrix}
1&0&t_x\\0&1&t_y\\0&0&1
\end{bmatrix}\\
S_{s}&=\begin{bmatrix}
s&0&0\\0&s&0\\0&0&1
\end{bmatrix}
\end{aligned}
++++

In general, an arbitrary transformation has six{empty}footnote:[Why six? Because a 3×3 matrix has nine entries, but its bottom row must be all 0s and then a 1.] parameters and has the form
[stem]
++++
\begin{bmatrix}
a&b&c\\d&e&f\\0&0&1
\end{bmatrix}
++++

[sidebar]
====
Actually, this isn't quite true.
Transformations can also act along the z-axis, transforming shapes so that they no longer lie in the plane of the screen.
These transformations are 4×4 and have 4×(4-1)=12 parameters.
We won't consider them further.
====

[TIP]
====
The full list of transform functions is available https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function[here].
The `elem.getCTM()` function will retrieve the computed https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix[`DOMMatrix`] that is applied to an SVG element.
For an HTML element, you can use `window.getComputedStyle(elem).transform`, but note that this might return `none` if there is no `transform` in the element's style.
====

One can verify that these act as expected, i.e., that
[stem]
++++
\begin{aligned}
T_{t_x,t_y}\begin{bmatrix}x\\y\\1\end{bmatrix}&=\begin{bmatrix}x+t_x\\y+t_y\\1\end{bmatrix}\\
S_s\begin{bmatrix}x\\y\\1\end{bmatrix}&=\begin{bmatrix}sx\\sy\\1\end{bmatrix}
\end{aligned}
++++

Now, assuming the SVG's `viewBox` is `"x y w h"` with `w < h`, the first version of the `transform` was
[stem]
++++
\begin{aligned}
T_{\frac{1}{2}-(x+\tfrac{w}{2})/h,\tfrac{1}{2}-(y+\tfrac{h}{2})/h}S_{\tfrac{1}{h}}&=\begin{bmatrix}
1&0&\tfrac{1}{2}-(x+\tfrac{w}{2})/h\\0&1&\tfrac{1}{2}-(y+\tfrac{h}{2})/h\\0&0&1
\end{bmatrix}\begin{bmatrix}
\tfrac{1}{h}&0&0\\0&\tfrac{1}{h}&0\\0&0&1
\end{bmatrix}\\
&=\begin{bmatrix}
\tfrac{1}{h}&0&\tfrac{1}{2}-(x+\frac{w}{2})/h\\0&\tfrac{1}{h}&\tfrac{1}{2}-(y+\tfrac{h}{2})/h\\0&0&1
\end{bmatrix}
\end{aligned}
++++

whereas the second version was
[stem]
++++
\begin{aligned}
T_{\tfrac{1}{2},\tfrac{1}{2}}S_{\tfrac{1}{h}}T_{-(x+\tfrac{w}{2}),-(y+\tfrac{h}{2})}&=\begin{bmatrix}
0&0&\tfrac{1}{2}\\0&0&\tfrac{1}{2}\\0&0&1
\end{bmatrix}\begin{bmatrix}
\tfrac{1}{h}&0&0\\0&\tfrac{1}{h}&0\\0&0&1
\end{bmatrix}\begin{bmatrix}
0&0&-\left(x+\tfrac{w}{2}\right)\\0&0&-\left(y+\tfrac{h}{2}\right)\\0&0&1
\end{bmatrix}\\
&=\begin{bmatrix}
\tfrac{1}{h}&0&\tfrac{1}{2}-(x+\frac{w}{2})/h\\0&\tfrac{1}{h}&\tfrac{1}{2}-(y+\tfrac{h}{2})/h\\0&0&1
\end{bmatrix}
\end{aligned}
++++

They're equal, so, as we'd hope, the two solutions we found correspond to the same linear transformation.
